<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Session Log Viewer</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      background: #1a1a2e;
      color: #e0e0e0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    .toolbar {
      background: #16213e;
      padding: 8px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid #0f3460;
      flex-shrink: 0;
    }
    .toolbar h1 {
      font-size: 14px;
      font-weight: 600;
      color: #a0c4ff;
    }
    .toolbar .filename {
      font-size: 12px;
      color: #7a8ba0;
    }
    .toolbar select {
      background: #1a1a2e;
      color: #e0e0e0;
      border: 1px solid #0f3460;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 12px;
      font-family: inherit;
      cursor: pointer;
    }
    .toolbar select:focus {
      outline: none;
      border-color: #a0c4ff;
    }
    .toolbar .status {
      margin-left: auto;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .toolbar .status .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #4ade80;
      animation: pulse 2s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }
    .toolbar .auto-scroll-label {
      font-size: 12px;
      color: #7a8ba0;
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }
    .toolbar .auto-scroll-label input {
      cursor: pointer;
    }
    .toolbar .btn-delete {
      background: transparent;
      border: 1px solid #ef4444;
      color: #ef4444;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .toolbar .btn-delete:hover {
      background: #ef4444;
      color: #fff;
    }
    .toolbar .btn-delete:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    .toolbar .btn-delete:disabled:hover {
      background: transparent;
      color: #ef4444;
    }
    .log-container {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }
    .log-content {
      white-space: pre-wrap;
      word-break: break-all;
      font-size: 13px;
      line-height: 1.5;
    }
    .log-line {
      padding: 1px 4px;
      border-radius: 2px;
    }
    .log-line.highlight {
      background: #3b2e00;
      border-left: 3px solid #f59e0b;
      padding-left: 8px;
      animation: flash 2s ease-out;
    }
    @keyframes flash {
      0% { background: #5a4400; }
      100% { background: #3b2e00; }
    }
    .log-line.separator {
      color: #4a6a8a;
    }
    .log-line.header {
      color: #a0c4ff;
      font-weight: 600;
    }
    .log-line.timestamp {
      color: #7dd3fc;
    }
    .log-line.error-line {
      color: #f87171;
      font-weight: 600;
    }
    .log-line.curl-line {
      color: #86efac;
    }
    .log-line.step-complete {
      color: #4ade80;
    }
    .empty-state {
      color: #7a8ba0;
      text-align: center;
      padding: 60px 20px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <h1>Session Log</h1>
    <select id="log-select">
      <option value="current">Current Session</option>
    </select>
    <button class="btn-delete" id="delete-btn" disabled title="Delete selected log file">Delete</button>
    <label class="auto-scroll-label">
      <input type="checkbox" id="auto-scroll" checked> Auto-scroll
    </label>
    <div class="status" id="live-status">
      <span class="dot"></span>
      <span>Live</span>
    </div>
  </div>
  <div class="log-container" id="log-container">
    <div class="empty-state">Waiting for log data...</div>
  </div>

  <script>
    const CURRENT_USER_KEY = 'okta_current_user';
    const container = document.getElementById('log-container');
    const logSelect = document.getElementById('log-select');
    const deleteBtn = document.getElementById('delete-btn');
    const autoScrollCheckbox = document.getElementById('auto-scroll');
    const liveStatus = document.getElementById('live-status');
    let lastContent = '';
    let targetTimestamp = null;
    let hasScrolledToTarget = false;
    let selectedLog = 'current';
    let pollInterval = null;
    let currentUser = null;
    let logFiles = [];

    // Get current user from localStorage
    try {
      const userJson = localStorage.getItem(CURRENT_USER_KEY);
      if (userJson) {
        currentUser = JSON.parse(userJson);
      }
    } catch {}

    // Check for timestamp in URL hash
    if (window.location.hash) {
      targetTimestamp = decodeURIComponent(window.location.hash.substring(1));
    }

    // Check for step parameter in URL query string
    let targetStep = null;
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('step')) {
      targetStep = urlParams.get('step');
    }

    function formatLogContent(text) {
      // Remove META line from display
      const lines = text.split('\n').filter(line => !line.startsWith('<!-- META:'));

      // If targeting a step, find the last occurrence of that step's log entry
      let lastStepLineIndex = -1;
      if (targetStep) {
        const stepPattern = new RegExp(`^----- \\[.*\\] Step ${targetStep}:`);
        for (let i = lines.length - 1; i >= 0; i--) {
          if (stepPattern.test(lines[i])) {
            lastStepLineIndex = i;
            break;
          }
        }
      }

      return lines.map((line, i) => {
        let cls = 'log-line';
        const id = `line-${i}`;

        if (line.startsWith('=====')) {
          cls += ' separator';
        } else if (line.match(/^\s+(.*Session|Started:|User:)/)) {
          cls += ' header';
        } else if (line.match(/^----- \[/)) {
          cls += ' timestamp';
          if (line.includes('ERROR')) {
            cls += ' error-line';
          } else if (line.includes('complete')) {
            cls += ' step-complete';
          }
        } else if (line.match(/^curl |^  -[HXd] /)) {
          cls += ' curl-line';
        } else if (line.includes('ERROR') || line.includes('error:')) {
          cls += ' error-line';
        }

        // Check if this line contains the target timestamp for highlighting
        if (targetTimestamp && line.includes(targetTimestamp)) {
          cls += ' highlight';
          return `<div class="${cls}" id="target-line" data-line="${id}">${escapeHtml(line)}</div>`;
        }

        // Highlight last occurrence of target step
        if (i === lastStepLineIndex) {
          cls += ' highlight';
          return `<div class="${cls}" id="target-line" data-line="${id}">${escapeHtml(line)}</div>`;
        }

        return `<div class="${cls}" data-line="${id}">${escapeHtml(line)}</div>`;
      }).join('');
    }

    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function formatOptionLabel(file, isCurrent) {
      const parts = [];

      // Format date/time from filename or startedAt
      if (file.startedAt) {
        const d = new Date(file.startedAt);
        parts.push(d.toLocaleString('en-US', {
          month: 'short', day: 'numeric',
          hour: '2-digit', minute: '2-digit'
        }));
      } else {
        // Fallback: parse from filename
        const match = file.filename.match(/session-[a-z-]+-(\d{4})-(\d{2})-(\d{2})T(\d{2})-(\d{2})/);
        if (match) {
          parts.push(`${match[2]}/${match[3]} ${match[4]}:${match[5]}`);
        }
      }

      // Add flow name
      if (file.flowDisplayName) {
        parts.push(`[${file.flowDisplayName}]`);
      }

      // Add user
      if (file.user) {
        const isCurrentUser = currentUser && (
          file.user === currentUser.name ||
          file.user === currentUser.email ||
          file.user === currentUser.sub
        );
        if (isCurrentUser) {
          parts.push(`★ ${file.user}`);
        } else {
          parts.push(file.user);
        }
      }

      if (isCurrent) {
        parts.push('(current)');
      }

      return parts.join(' · ');
    }

    async function fetchLogList() {
      try {
        const res = await fetch('/api/logs');
        const data = await res.json();
        logFiles = data.files || [];

        // Populate dropdown
        logSelect.innerHTML = '<option value="current">Current Session</option>';
        if (logFiles.length > 0) {
          const separator = document.createElement('option');
          separator.disabled = true;
          separator.textContent = '── Previous Sessions ──';
          logSelect.appendChild(separator);

          for (const file of logFiles) {
            const opt = document.createElement('option');
            opt.value = file.filename;
            const isCurrent = data.current === file.filename;
            opt.textContent = formatOptionLabel(file, isCurrent);
            logSelect.appendChild(opt);
          }
        }

        // Update delete button state
        updateDeleteButton();
      } catch (err) {
        console.error('Failed to fetch log list:', err);
      }
    }

    async function fetchLog() {
      try {
        const endpoint = selectedLog === 'current'
          ? '/api/logs/current'
          : `/api/logs/${encodeURIComponent(selectedLog)}`;

        const res = await fetch(endpoint);
        const data = await res.json();

        if (data.content && data.content !== lastContent) {
          lastContent = data.content;
          container.innerHTML = `<div class="log-content">${formatLogContent(data.content)}</div>`;

          // Scroll to target timestamp or target step on first load
          if ((targetTimestamp || targetStep) && !hasScrolledToTarget) {
            const target = document.getElementById('target-line');
            if (target) {
              target.scrollIntoView({ behavior: 'smooth', block: 'center' });
              hasScrolledToTarget = true;
            }
          } else if (autoScrollCheckbox.checked && selectedLog === 'current') {
            container.scrollTop = container.scrollHeight;
          }
        }
      } catch (err) {
        container.innerHTML = '<div class="empty-state">Failed to load log file.</div>';
      }
    }

    function updateLiveStatus() {
      if (selectedLog === 'current') {
        liveStatus.style.display = 'flex';
        if (!pollInterval) {
          pollInterval = setInterval(fetchLog, 1000);
        }
      } else {
        liveStatus.style.display = 'none';
        if (pollInterval) {
          clearInterval(pollInterval);
          pollInterval = null;
        }
      }
    }

    function updateDeleteButton() {
      // Can only delete non-current session logs
      const canDelete = selectedLog !== 'current' && logFiles.some(f =>
        f.filename === selectedLog &&
        logFiles.find(l => l.filename === selectedLog)
      );
      deleteBtn.disabled = selectedLog === 'current';
    }

    async function deleteSelectedLog() {
      if (selectedLog === 'current') return;

      if (!confirm(`Delete this log file?\n\n${selectedLog}`)) {
        return;
      }

      try {
        const res = await fetch(`/api/logs/${encodeURIComponent(selectedLog)}`, {
          method: 'DELETE',
        });

        if (!res.ok) {
          const data = await res.json();
          alert(`Failed to delete: ${data.error}`);
          return;
        }

        // Reset to current session and refresh
        selectedLog = 'current';
        logSelect.value = 'current';
        lastContent = '';
        updateLiveStatus();
        updateDeleteButton();
        await fetchLogList();
        await fetchLog();
      } catch (err) {
        alert(`Failed to delete: ${err.message}`);
      }
    }

    // Handle log selection change
    logSelect.addEventListener('change', () => {
      selectedLog = logSelect.value;
      lastContent = '';
      hasScrolledToTarget = false;
      updateLiveStatus();
      updateDeleteButton();
      fetchLog();
    });

    // Handle delete button click
    deleteBtn.addEventListener('click', deleteSelectedLog);

    // Initial fetch
    fetchLogList();
    fetchLog();
    updateLiveStatus();

    // Refresh log list periodically
    setInterval(fetchLogList, 10000);

    // Pause auto-scroll when user scrolls up
    container.addEventListener('scroll', () => {
      const atBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 50;
      if (!atBottom && !targetTimestamp) {
        autoScrollCheckbox.checked = false;
      }
    });
  </script>
</body>
</html>
